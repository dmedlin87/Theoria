#!/usr/bin/env python3
"""Generate consolidated handoff documents for AI agents.

The script assembles two artefacts from existing handoff materials:

* ``AGENT_CONTEXT.md`` — a comprehensive context bundle.
* ``QUICK_START_AGENTS.md`` — a trimmed quick-start checklist.

Each artefact contains a metadata header with repository information so
maintainers can confirm when the bundle was regenerated.
"""

from __future__ import annotations

import argparse
import subprocess
from datetime import datetime, timezone
from pathlib import Path
from typing import Iterable, Sequence

REPO_ROOT = Path(__file__).resolve().parents[2]
OUTPUT_AGENT_CONTEXT = REPO_ROOT / "AGENT_CONTEXT.md"
OUTPUT_QUICK_START = REPO_ROOT / "QUICK_START_AGENTS.md"

AGENT_CONTEXT_SOURCES: Sequence[tuple[str, str]] = (
    ("AGENT_HANDOFF_COMPLETE.md", "Agent Handoff Package"),
    ("HANDOFF_SESSION_2025_10_15.md", "Session Summary (2025-10-15)"),
    ("HANDOFF_MYPY_FIXES_2025_10_17.md", "Strict Typing Follow-up"),
    ("HANDOFF_NEXT_PHASE.md", "Next Phase Roadmap"),
    ("IMPLEMENTATION_CONTEXT.md", "Implementation Context"),
)

QUICK_START_SOURCES: Sequence[tuple[str, str]] = (
    ("QUICK_START_FOR_AGENTS.md", "Primary Quick Start"),
    ("HANDOFF_NEXT_PHASE.md", "Phase Roadmap"),
    ("AGENT_HANDOFF_COMPLETE.md", "Handoff Overview"),
)


class GenerationError(RuntimeError):
    """Raised when the generator encounters a fatal error."""


def _read_file(path: Path) -> str:
    try:
        return path.read_text(encoding="utf-8").strip()
    except FileNotFoundError as exc:  # pragma: no cover - defensive
        raise GenerationError(f"Source document not found: {path.relative_to(REPO_ROOT)}") from exc


def _run_git(*args: str) -> str:
    try:
        result = subprocess.run(
            ["git", *args],
            cwd=REPO_ROOT,
            check=True,
            capture_output=True,
            text=True,
        )
    except (OSError, subprocess.CalledProcessError):  # pragma: no cover - defensive
        return "unknown"
    return result.stdout.strip()


def _metadata_block(sources: Iterable[Path]) -> str:
    commit = _run_git("rev-parse", "HEAD")
    branch = _run_git("rev-parse", "--abbrev-ref", "HEAD")
    remote = _run_git("remote", "get-url", "origin")
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S %Z")
    src_list = "\n".join(f"> - {path.relative_to(REPO_ROOT)}" for path in sources)
    return (
        "<!-- Generated by scripts/docs/create_agent_context.py -->\n"
        "\n"
        f"> Generated: {timestamp}\n"
        f"> Source commit: {commit}\n"
        f"> Branch: {branch}\n"
        f"> Remote: {remote}\n"
        f"> Source files:\n{src_list}\n"
    )


def _normalise_section(title: str, content: str) -> str:
    lines = content.splitlines()
    if not lines:
        return f"## {title}\n\n_(empty source)_"

    adjusted: list[str] = []
    for line in lines:
        stripped = line.lstrip()
        if stripped.startswith("#") and not line.startswith("    ") and not line.startswith("\t"):
            # Promote headings to at least H2 to avoid multiple H1 entries.
            level = len(stripped) - len(stripped.lstrip("#"))
            heading_text = stripped[level:].lstrip()
            new_level = max(2, level + 1)
            adjusted.append("#" * new_level + " " + heading_text)
        else:
            adjusted.append(line)
    section_body = "\n".join(adjusted).strip()
    return f"## {title}\n\n{section_body}\n"


def build_document(sources: Sequence[tuple[str, str]], output_path: Path, *, dry_run: bool) -> None:
    resolved_sources = [REPO_ROOT / src for src, _ in sources]
    metadata = _metadata_block(resolved_sources)
    sections = []
    for (source_path, title) in sources:
        content = _read_file(REPO_ROOT / source_path)
        sections.append(_normalise_section(title, content))
    document = "\n---\n\n".join([metadata, *sections]) + "\n"

    if dry_run:
        print(f"[dry-run] would write {output_path.relative_to(REPO_ROOT)}")
        return

    output_path.write_text(document, encoding="utf-8")
    print(f"Wrote {output_path.relative_to(REPO_ROOT)}")


def parse_args(argv: list[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--dry-run", action="store_true", help="Preview output paths without writing files")
    parser.add_argument(
        "--agent-context",
        dest="agent_context_path",
        type=Path,
        default=OUTPUT_AGENT_CONTEXT,
        help="Override output path for AGENT_CONTEXT.md",
    )
    parser.add_argument(
        "--quick-start",
        dest="quick_start_path",
        type=Path,
        default=OUTPUT_QUICK_START,
        help="Override output path for QUICK_START_AGENTS.md",
    )
    return parser.parse_args(argv)


def main(argv: list[str] | None = None) -> int:
    options = parse_args(argv)

    try:
        build_document(AGENT_CONTEXT_SOURCES, options.agent_context_path, dry_run=options.dry_run)
        build_document(QUICK_START_SOURCES, options.quick_start_path, dry_run=options.dry_run)
    except GenerationError as exc:
        print(f"Error: {exc}", file=sys.stderr)
        return 1
    return 0


if __name__ == "__main__":
    import sys

    sys.exit(main())
